using System;
using System.Collections.Generic;
using System.Text;
using System.Data;
using System.Threading;
using QuickFix;
using NestDLL;

namespace NFIXConn
{
    /// <summary>
    /// FIX interface to send the orders generated by strategies
    /// </summary>
    public class FIXConn : MessageCracker, QuickFix.Application, IDisposable
    {
        private SessionSettings _settings;
        private FileStoreFactory _store;
        private FileLogFactory _logs;
        private MessageFactory _messages;
        private SocketInitiator _initiator;
        private string _QFConfig;
        private SessionID _ID_Session = null;
        public int ordID = 0;
        private bool _IsAliveSession = false;
        public bool IsAliveSession
        {
            get { return _IsAliveSession; }
        }


        private SortedDictionary<string, Order> OrderContainer = new SortedDictionary<string, Order>();
        private Mutex MutexOrderContainer = new Mutex();

        /// <summary>
        /// Event executed when a Fill or Partial Fill Execution Report is received
        /// </summary>
        public event EventHandler ReceivedFill;

        #region Properties

        /// <summary>
        /// Full path to QuickFix configuration File
        /// </summary>
        public string QFConfig
        {
            get
            {
                return _QFConfig;
            }
        }

        /// <summary>
        /// Unique session identifier
        /// </summary>
        public QuickFix.SessionID ID_Session
        {
            get
            {
                return _ID_Session;
            }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Create instance of FIX class
        /// </summary>
        /// <param name="_qfConfig">QuickFix configuration file full path</param>
        public FIXConn(string _qfConfig)
        {
            _QFConfig = _qfConfig;

            try
            {
                _settings = new SessionSettings(QFConfig);
                _store = new FileStoreFactory(_settings);
                _logs = new FileLogFactory(_settings);
                _messages = new DefaultMessageFactory();
                _initiator = new SocketInitiator(this, _store, _settings, _logs, _messages);

                _initiator.start();
            }
            catch (Exception e)
            {
                throw new Exception("Unable to create instance of class FIX", e);
            }//catch

            getLastOrdID();

        }//FIX

        #endregion

        #region Send Messages
                
        public string sendOrder(int ID_Ticker, int Qty, double price, int IdPortfolio, int IdBook, int IdSection)
        {
            string result = sendOrder(ID_Ticker, Qty,price, IdPortfolio, IdBook, IdSection, "");

            return result;
        }

        public string sendOrder(int ID_Ticker, int Qty, double price, int IdPortfolio, int IdBook, int IdSection, bool DontMatch)
        {
            string OrderType = (Qty >= 0 ? NCommonTypes.NEnuns.NOrderType.Buy : NCommonTypes.NEnuns.NOrderType.Sell);

            string result = sendOrder(nextClOrderID(), ID_Ticker, Qty, price, IdPortfolio, IdBook, IdSection, "", OrderType, DontMatch);

            return result;
        }

        public string sendOrder(int ID_Ticker, int Qty, double price, int IdPortfolio, int IdBook, int IdSection, string extension)
        {
            string OrderType = (Qty >= 0 ? NCommonTypes.NEnuns.NOrderType.Buy : NCommonTypes.NEnuns.NOrderType.Sell);

            string result = sendOrder(nextClOrderID(), ID_Ticker, Qty, price, IdPortfolio, IdBook, IdSection, extension,OrderType, false);

            return result;
        }

        public string sendOrder(string OrderID, int ID_Ticker, int Qty, double price, int IdPortfolio, int IdBook, int IdSection)
        {

            string OrderType = (Qty >= 0 ? NCommonTypes.NEnuns.NOrderType.Buy : NCommonTypes.NEnuns.NOrderType.Sell);

            string result = sendOrder(OrderID, ID_Ticker, Qty, price, IdPortfolio, IdBook, IdSection,"",OrderType, false);

            return result;
        }

        /// <summary>
        /// Send order
        /// </summary>
        /// <param name="ID_Ticker">Ticker to buy/sell</param>
        /// <param name="Qty">Quantity to buy/sell</param>
        /// <param name="price">Price to buy/sell. Use -1 to buy at market price</param>
        public string sendOrder(string OrderID, int ID_Ticker, int Qty, double price, int IdPortfolio, int IdBook, int IdSection, string extension, string OrderType, bool DontMatch)
        {
            ClOrdID _clOrdId = new ClOrdID(nextClOrderID());
            HandlInst _handlInst = new HandlInst(HandlInst.AUTOMATED_EXECUTION_ORDER_PRIVATE);

            string symbol = getSymbol(ID_Ticker).Split('.')[0];



            if (extension != "")
            {
                symbol = symbol + "." + extension;
            }

            Symbol _symbol = new Symbol(symbol);
            //Side _side = new Side((Qty >= 0 ? Side.BUY : Side.SELL));
            Side _side = new Side();

            if (OrderType == NCommonTypes.NEnuns.NOrderType.Buy) { _side = new Side(Side.BUY); }
            else if (OrderType == NCommonTypes.NEnuns.NOrderType.Sell) { _side = new Side(Side.SELL); }
            else if (OrderType == NCommonTypes.NEnuns.NOrderType.BuyToCover) { _side = new Side(Side.BUY); }
            else if (OrderType == NCommonTypes.NEnuns.NOrderType.SellShort) { _side = new Side(Side.SELL_SHORT); }


            TransactTime _tTime = new TransactTime(DateTime.Now);
            OrdType _ordType = new OrdType();

            if (price > 0)
            {
                _ordType.setValue(OrdType.LIMIT);
            }
            else
            {
                _ordType.setValue(OrdType.MARKET);
            }

            OrderQty _qty = new OrderQty((double)(Math.Abs(Qty)));
            Price _price = new Price();

            QuickFix42.NewOrderSingle orderSingle = new QuickFix42.NewOrderSingle(_clOrdId,
                                                                                  _handlInst,
                                                                                  _symbol,
                                                                                  _side,
                                                                                  _tTime,
                                                                                  _ordType);

            orderSingle.set(_qty);

            if (price > 0)
            {
                _price.setValue(price);
                orderSingle.set(_price);
            }

            if (price == -2)
            {
                orderSingle.setString(9304, "Y");
            }
            else
            {
                orderSingle.setString(9304, "N");
            }

            orderSingle.setInt(9305, IdBook);
            orderSingle.setInt(9306, IdSection);
            orderSingle.setInt(9307, IdPortfolio);
            if (DontMatch) { orderSingle.setString(9308, "Y"); } else { orderSingle.setString(9308, "N"); }

            Order newOrd = new Order(_clOrdId, ID_Ticker, _symbol, _side, _qty, _price);
            OrderContainer.Add(_clOrdId.getValue(), newOrd);

            Session.sendToTarget(orderSingle, ID_Session);

            return _clOrdId.getValue();
        }

        /// <summary>
        /// Returns the symbol (string) of a given Ticker ID
        /// </summary>
        /// <param name="ID_Ticker">Ticker to get symbol</param>
        /// <returns>Symbol of the given Ticker ID</returns>
        private string getSymbol(int ID_Ticker)
        {
            string SQLExpresion = "SELECT EXCHANGETICKER FROM NESTSRV06.NESTDB.DBO.TB001_SECURITIES WITH(NOLOCK) WHERE IDSECURITY = " + ID_Ticker.ToString();

            string result = "";

            using (newNestConn conn = new newNestConn(true))
            {
                if ((result = conn.Execute_Query_String(SQLExpresion)) == "")
                {
                    throw new System.NotImplementedException();
                }
            }

            return result;
        }

        public void cancelAllOrders(int ID_Ticker)
        {
            foreach (Order ord in OrderContainer.Values)
            {
                if (ord.ID_Ticker == ID_Ticker)
                {
                    cancelOrder(ord.ClOrdID.getValue());
                }
            }
        }

        public bool cancelOrder(string clOrdID)
        {
            bool result = false;

            if (OrderContainer.ContainsKey(clOrdID))
            {
                if (OrderContainer[clOrdID].Status.getValue() == OrdStatus.NEW ||
                    OrderContainer[clOrdID].Status.getValue() == OrdStatus.PARTIALLY_FILLED ||
                    OrderContainer[clOrdID].Status.getValue() == OrdStatus.PENDING_CANCEL)
                {

                    QuickFix42.OrderCancelRequest cancel = new QuickFix42.OrderCancelRequest(new OrigClOrdID(OrderContainer[clOrdID].ClOrdID.getValue()),
                                                                                             new ClOrdID(nextClOrderID()),
                                                                                             OrderContainer[clOrdID].Symbol,
                                                                                             OrderContainer[clOrdID].Side,
                                                                                             new TransactTime(DateTime.Now));
                    cancel.set(OrderContainer[clOrdID].OrderQty);
                    Session.sendToTarget(cancel, ID_Session);

                    result = true;
                }
            }

            return result;
        }

        private string nextClOrderID()
        {
            return "IAA" + getNextOrdID().ToString("0000");
        }

        private void getLastOrdID()
        {
            if (DateTime.Today.Equals(NFIXConn.Properties.Settings.Default.LastClOrdIDDate))
            {
                ordID = NFIXConn.Properties.Settings.Default.LastClOrdID;
            }
            else
            {
                NFIXConn.Properties.Settings.Default.LastClOrdIDDate = DateTime.Today;
                ordID = 0;
                NFIXConn.Properties.Settings.Default.LastClOrdID = ordID;
                NFIXConn.Properties.Settings.Default.Save();
            }
        }

        private int getNextOrdID()
        {
            if (DateTime.Today.Equals(NFIXConn.Properties.Settings.Default.LastClOrdIDDate))
            {
                ordID++;
                NFIXConn.Properties.Settings.Default.LastClOrdID = ordID;
                NFIXConn.Properties.Settings.Default.Save();
            }
            else
            {
                NFIXConn.Properties.Settings.Default.LastClOrdIDDate = DateTime.Today;
                ordID = 0;
                NFIXConn.Properties.Settings.Default.LastClOrdID = ordID;
                NFIXConn.Properties.Settings.Default.Save();
            }

            return ordID;
        }

        #endregion

        #region Receive Messages

        /// <summary>
        /// Handle the messages received through the FIX connection
        /// </summary>
        /// <param name="message">Received Execution Report message</param>
        /// <param name="session">Session of the message</param>
        public override void onMessage(QuickFix42.ExecutionReport message, SessionID session)
        {
            switch (message.getExecTransType().getValue())
            {
                case ExecTransType.NEW://New Execution Report
                    switch (message.getExecType().getValue())
                    {
                        case ExecType.NEW: //The order was accepted by the broker
                        case ExecType.PENDING_CANCEL: //The cancel order was received by the broker but not executed yet
                        case ExecType.CANCELED: //The order was cancelled
                            ChangeOrderStatus(message, session);
                            break;
                        case ExecType.PARTIAL_FILL://The order was partially executed
                        case ExecType.FILL://The order was completely executed
                            ExecutionFill(message, session);

                            switch (message.getOrdStatus().getValue())
                            {
                                case OrdStatus.PARTIALLY_FILLED:
                                case OrdStatus.FILLED:
                                    ChangeOrderStatus(message, session);
                                    break;
                                default:
                                    break;
                            }

                            break;
                        default:
                            break;
                    }//switch (message.getExecType().getValue())
                    break;
                case ExecTransType.CANCEL://Sent by broker to cancel a previous Execution Report
                    //TODO: Implementar tratamento de ExecTransType.CANCEL para ExecutionReport
                    break;
                case ExecTransType.CORRECT://Sent by broker to correct a previous Execution Report
                    //TODO: Implementar tratamento de ExecTransType.CORRECT para ExecutionReport
                    break;
                case ExecTransType.STATUS: //Sent by broker only after a Status Request
                    //TODO: Implementar tratamento de ExecTransType.STATUS para ExecutionReport
                    break;
                default:
                    throw new Exception("Invalid Execution Report ExecTransType: " + message.getExecTransType().ToString() + "\r\n" +
                                        "Original Message: \r\n" + message.ToXML());
                    break;
            }//switch (message.getExecTransType().getValue())

        }//onMessage(QuickFix42.ExecutionReport message, SessionID session)

        /// <summary>
        /// Method to process Fill and Partial Fill Execution Reports
        /// </summary>
        /// <param name="message">Fill or Partial Fill Execution Report</param>
        /// <param name="session">Unique session identifier</param>
        private void ExecutionFill(QuickFix42.ExecutionReport message, SessionID session)
        {
            bool allFieldsSet = true;

            Symbol symbol = new Symbol();
            OrderQty orderQty = new OrderQty();
            CumQty cumQty = new CumQty();
            LeavesQty leavesQty = new LeavesQty();
            LastShares lastShares = new LastShares();
            Side side = new Side();

            if (message.isSet(symbol)) { message.get(symbol); } else { allFieldsSet = false; }
            if (message.isSet(orderQty)) { message.get(orderQty); } else { allFieldsSet = false; }
            if (message.isSet(cumQty)) { message.get(cumQty); } else { allFieldsSet = false; }
            if (message.isSet(leavesQty)) { message.get(leavesQty); } else { allFieldsSet = false; }
            if (message.isSet(lastShares)) { message.get(lastShares); } else { allFieldsSet = false; }
            if (message.isSet(side)) { message.get(side); } else { allFieldsSet = false; }

            if (allFieldsSet)
            {
                ClOrdID clOrdId = new ClOrdID();

                if (OrderContainer.ContainsKey(message.get(clOrdId).getValue()))
                {
                    OrderContainer[clOrdId.getValue()].FillOrder(clOrdId, lastShares, cumQty);


                    NCommonTypes.ExecutionFillArgs fillArgs = new NCommonTypes.ExecutionFillArgs(OrderContainer[clOrdId.getValue()].ID_Ticker,
                                                                       (int)orderQty.getValue(),
                                                                       (int)cumQty.getValue(),
                                                                       (int)leavesQty.getValue(),
                                                                       (side.getValue() == Side.SELL ? (-1) : (1)) * (int)lastShares.getValue(),
                                                                       clOrdId.getValue());

                    if (ReceivedFill != null)
                    {
                        ReceivedFill(this, fillArgs);
                    }
                }
            }


        }//ExecutionFill(QuickFix42.ExecutionReport message, SessionID session)

        /// <summary>
        /// Changes the status of an order
        /// </summary>
        /// <param name="message">Message with the new status</param>
        /// <param name="session">Unique session identifier</param>
        private void ChangeOrderStatus(QuickFix42.ExecutionReport message, SessionID session)
        {
            string clOrdID = "";

            if (message.getExecType().getValue() == ExecType.PENDING_CANCEL)
            {
                clOrdID = message.getOrigClOrdID().getValue();
            }
            else
            {
                clOrdID = message.getClOrdID().getValue();
            }

            MutexOrderContainer.WaitOne();
            if (OrderContainer.ContainsKey(clOrdID))
            {
                OrderContainer[clOrdID].ChangeStatus(message.getOrdStatus());
            }
            MutexOrderContainer.ReleaseMutex();
        }

        #endregion

        #region QuickFix Events
        /// <summary>
        /// Called on FIX session creation
        /// </summary>
        /// <param name="sessionID">Identifies uniquely the session</param>
        public void onCreate(SessionID sessionID)
        {
            _ID_Session = sessionID;
        }

        /// <summary>
        /// Called on successful logon
        /// </summary>
        /// <param name="sessionID">Identifies uniquely the session</param>
        public void onLogon(SessionID sessionID)
        {
            _IsAliveSession = true;
        }

        /// <summary>
        /// Called when connection ends
        /// </summary>
        /// <param name="sessionID">Identifies uniquely the session</param>
        public void onLogout(SessionID sessionID)
        {
            _IsAliveSession = false;
        }

        /// <summary>
        /// Called before the application sends a session message
        /// </summary>
        /// <param name="message">FIX message</param>
        /// <param name="sessionID">Identifies uniquely the session</param>
        public void toAdmin(Message message, SessionID sessionID)
        {
        }

        /// <summary>
        /// Called when a session message is received
        /// </summary>
        /// <param name="message">FIX message</param>
        /// <param name="sessionID">Identifies uniquely the session</param>
        public void fromAdmin(Message message, SessionID sessionID)
        {
            crack(message, sessionID);
        }

        /// <summary>
        /// Called before the application sends an application message
        /// </summary>
        /// <param name="message">FIX message</param>
        /// <param name="sessionID">Identifies uniquely the session</param>
        public void toApp(Message message, SessionID sessionID)
        {
            //SenderSubID _senderSubId = new SenderSubID("UA");

            //if (!message.isSetField(_senderSubId)) { message.setField(_senderSubId); }
        }

        /// <summary>
        /// Called when an application message is received
        /// </summary>
        /// <param name="message">FIX message</param>
        /// <param name="sessionID">Identifies uniquely the session</param>
        public void fromApp(Message message, SessionID sessionID)
        {
            try
            {
                crack(message, sessionID);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                Console.WriteLine(message.ToXML());
            }
        }
        #endregion

        #region Disposable Region

        /// <summary>
        /// Disposes FIX class
        /// </summary>
        public void Dispose()
        {
            _initiator.stop();
        }//Dispose



        #endregion

    }//FixConn

    /// <summary>
    /// Represents a sent order
    /// </summary>
    public class Order
    {
        private ClOrdID _ClOrdID;

        public ClOrdID ClOrdID
        {
            get { return _ClOrdID; }
        }
        private OrigClOrdID _OrigClOrdID;

        public OrigClOrdID OrigClOrdID
        {
            get { return _OrigClOrdID; }
        }
        private int _ID_Ticker;
        private Symbol _Symbol;

        public Symbol Symbol
        {
            get { return _Symbol; }
            set { _Symbol = value; }
        }
        private Side _Side;

        public Side Side
        {
            get { return _Side; }
            set { _Side = value; }
        }
        private OrderQty _OrderQty;

        public OrderQty OrderQty
        {
            get { return _OrderQty; }
            set { _OrderQty = value; }
        }
        private Price _Price;
        private OrdStatus _Status;

        public OrdStatus Status
        {
            get { return _Status; }
            set { _Status = value; }
        }
        private CumQty _CumQty;

        /// <summary>
        /// Class´ constructor
        /// </summary>
        /// <param name="id_Ticker">ID of the ticker</param>
        /// <param name="symbol">Symbol of the ticker</param>
        /// <param name="side">Order´s side</param>
        /// <param name="orderQty">Quantity of shares do buy/sell</param>
        /// <param name="price">Price to buy/sell shares</param>
        /// <param name="clOrdID">clOrdID of the order</param>
        public Order(ClOrdID clOrdID, int id_Ticker, Symbol symbol, Side side, OrderQty orderQty, Price price)
        {
            _ClOrdID = clOrdID;
            _ID_Ticker = id_Ticker;
            _Symbol = symbol;
            _Side = side;
            _OrderQty = orderQty;
            _Price = price;

            _OrigClOrdID = new OrigClOrdID(clOrdID.getValue());
            _CumQty = new CumQty(0);
            _Status = new OrdStatus(OrdStatus.PENDING_NEW);
        }

        public int ID_Ticker
        {
            get
            {
                return _ID_Ticker;
            }
        }

        /// <summary>
        /// Fills the order with the number of last shares received on an Execution Report
        /// </summary>
        /// <param name="clOrdId">ClOrdId of the order to be filled</param>
        /// <param name="lastShares">Qty of shares to fill</param>
        /// <param name="cumQty">Total of shares filled</param>
        public void FillOrder(ClOrdID clOrdId, LastShares lastShares, CumQty cumQty)
        {
            if (clOrdId.getValue() == ClOrdID.getValue())
            {
                _CumQty.setValue(_CumQty.getValue() + lastShares.getValue());
                if (_CumQty.getValue() != cumQty.getValue())
                {
                    Console.WriteLine("Last shares do not fill Order to the expected CumQty. Received: " + cumQty.ToString() + " Expected: " + _CumQty.ToString());
                }
            }
            else
            {
                throw new Exception("Incorrect ClOrdID on order fill. Received: " + clOrdId.ToString() + " Expected: " + ClOrdID.ToString());
            }
        }

        /// <summary>
        /// Changes the order´s status. Throws exception if the new status is unreachable from the current status
        /// </summary>
        /// <param name="ordStatus">New order status</param>
        public void ChangeStatus(OrdStatus ordStatus)
        {
            bool canChange = false;

            switch (Status.getValue())
            {
                case OrdStatus.PENDING_NEW:
                    switch (ordStatus.getValue())
                    {
                        case OrdStatus.NEW:
                        case OrdStatus.REJECTED:
                            canChange = true;
                            break;
                        default:
                            canChange = false;
                            break;
                    }
                    break;
                case OrdStatus.NEW:
                    switch (ordStatus.getValue())
                    {
                        case OrdStatus.NEW:
                        case OrdStatus.PARTIALLY_FILLED:
                        case OrdStatus.FILLED:
                        case OrdStatus.DONE_FOR_DAY:
                        case OrdStatus.PENDING_CANCEL:
                        case OrdStatus.PENDING_REPLACE:
                        case OrdStatus.REPLACED:
                        case OrdStatus.STOPPED:
                        case OrdStatus.REJECTED:
                            canChange = true;
                            break;
                        default:
                            canChange = false;
                            break;
                    }
                    break;
                case OrdStatus.PARTIALLY_FILLED:
                    switch (ordStatus.getValue())
                    {
                        case OrdStatus.PARTIALLY_FILLED:
                        case OrdStatus.FILLED:
                        case OrdStatus.DONE_FOR_DAY:
                        case OrdStatus.PENDING_CANCEL:
                        case OrdStatus.PENDING_REPLACE:
                        case OrdStatus.CANCELED:
                            canChange = true;
                            break;
                        default:
                            canChange = false;
                            break;
                    }
                    break;
                case OrdStatus.FILLED:
                    switch (ordStatus.getValue())
                    {
                        case OrdStatus.PARTIALLY_FILLED:
                        case OrdStatus.FILLED:
                        case OrdStatus.PENDING_REPLACE:
                            canChange = true;
                            break;
                        default:
                            canChange = false;
                            break;
                    }
                    break;
                case OrdStatus.DONE_FOR_DAY:
                    switch (ordStatus.getValue())
                    {
                        case OrdStatus.PARTIALLY_FILLED:
                            canChange = true;
                            break;
                        default:
                            canChange = false;
                            break;
                    }
                    break;
                case OrdStatus.PENDING_CANCEL:
                    switch (ordStatus.getValue())
                    {
                        case OrdStatus.NEW:
                        case OrdStatus.PARTIALLY_FILLED:
                        case OrdStatus.FILLED:
                        case OrdStatus.PENDING_CANCEL:
                        case OrdStatus.CANCELED:
                            canChange = true;
                            break;
                        default:
                            canChange = false;
                            break;
                    }
                    break;
                case OrdStatus.PENDING_REPLACE:
                    switch (ordStatus.getValue())
                    {
                        case OrdStatus.NEW:
                        case OrdStatus.PARTIALLY_FILLED:
                        case OrdStatus.FILLED:
                        case OrdStatus.PENDING_REPLACE:
                        case OrdStatus.REPLACED:
                        case OrdStatus.CANCELED:
                            canChange = true;
                            break;
                        default:
                            canChange = false;
                            break;
                    }
                    break;
                case OrdStatus.REPLACED:
                    switch (ordStatus.getValue())
                    {
                        case OrdStatus.PARTIALLY_FILLED:
                            canChange = true;
                            break;
                        default:
                            canChange = false;
                            break;
                    }
                    break;
                case OrdStatus.STOPPED:
                    switch (ordStatus.getValue())
                    {
                        case OrdStatus.PARTIALLY_FILLED:
                            canChange = true;
                            break;
                        default:
                            canChange = false;
                            break;
                    }
                    break;
                case OrdStatus.CANCELED:
                case OrdStatus.REJECTED:
                default:
                    canChange = false;
                    break;
            }

            if (canChange)
            {
                Status = ordStatus;
            }
            else
            {
                //throw new Exception("New order status unreachable. Current Status: " + Status.getValue() + " New Status: " + ordStatus.getValue());
            }
        }
    }//Order  

}
